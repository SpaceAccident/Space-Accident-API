package space.accident.api;

import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;
import net.minecraft.block.Block;
import net.minecraft.client.renderer.texture.IIconRegister;
import net.minecraft.item.ItemStack;
import net.minecraft.util.ChunkCoordinates;
import net.minecraft.world.World;
import net.minecraftforge.fluids.Fluid;
import space.accident.api.enums.Materials;
import space.accident.api.enums.OrePrefixes;
import space.accident.api.enums.Textures;
import space.accident.api.interfaces.IDamagableItem;
import space.accident.api.interfaces.ITexture;
import space.accident.api.interfaces.metatileentity.IMetaTile;
import space.accident.api.metatileentity.base.BaseMetaTileEntity;
import space.accident.api.metatileentity.implementations.logistic.Cable_Electricity;
import space.accident.api.metatileentity.implementations.logistic.Pipe_Fluid;
import space.accident.api.metatileentity.implementations.logistic.Pipe_Item;
import space.accident.api.objects.SA_Cover_Default;
import space.accident.api.objects.SA_Cover_None;
import space.accident.api.objects.ItemStackData;
import space.accident.api.objects.ReloadHashSet;
import space.accident.api.util.*;
import space.accident.main.MetaTileInfo;
import space.accident.main.threads.CableUpdateThreadThread;
import space.accident.main.threads.TileEntityUpdateThread;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import static space.accident.api.items.MetaGeneratedItem.MAX_COUNT_AUTOGENERATED_ITEMS;
import static space.accident.api.util.OreDictUnifier.registerOre;
import static space.accident.api.util.Utility.copyAmount;
import static space.accident.extensions.ItemStackUtils.isElectricItem;
import static space.accident.extensions.ItemStackUtils.isStackInList;

public class API {
	
	public static boolean isDebug = false;
	
	/**
	 * Fixes the HashMap Mappings for ItemStacks once the Server started
	 */
	public static final Collection<Map<ItemStackData, ?>> sItemStackMappings = new ArrayList<>();
	public static final Collection<Map<Fluid, ?>> sFluidMappings = new ArrayList<>();
	
	/**
	 * A List of all registered MetaTileEntities
	 *
	 * Check IDs in {@link MetaTileInfo}
	 *
	 * Contact me if you need a free ID-Range, which doesn't conflict with other Addons.
	 * You could make an ID-Config, but we all know, what "stupid" customers think about conflicting ID's
	 */
	public static final IMetaTile[] METATILEENTITIES = new IMetaTile[MAX_COUNT_AUTOGENERATED_ITEMS];
	
	/**
	 * The Icon List for Covers
	 */
	public static final Map<ItemStackData, ITexture> sCovers = new ConcurrentHashMap<>();
	
	/**
	 * The List of Cover Behaviors for the Covers
	 */
	public static final Map<ItemStackData, SA_CoverBehaviorBase<?>> sCoverBehaviors = new ConcurrentHashMap<>();
	public static final SA_CoverBehavior sDefaultBehavior = new SA_Cover_Default(), sNoBehavior = new SA_Cover_None();
	/**
	 * The List of all Sounds used in mod, indices are in the static Block at the bottom
	 */
	public static final Map<Integer, String> sSoundList = new ConcurrentHashMap<>();
	
	/**
	 * The List of Blocks, which can conduct Machine Block Updates
	 */
	public static final Map<Block, Integer> sMachineIDs = new ConcurrentHashMap<>();
	
	public static final List<Materials> RADIOACTIVITY_MATERIALS = new ArrayList<>();
	
	/**
	 * The List of Tools, which can be used. Accepts regular damageable Items and Electric Items
	 */
	public static final ReloadHashSet<ItemStackData>
			sToolList = new ReloadHashSet<>(),
			sCrowbarList = new ReloadHashSet<>(),
			sScrewdriverList = new ReloadHashSet<>(),
			sWrenchList = new ReloadHashSet<>(),
			sSoftHammerList = new ReloadHashSet<>(),
			sHardHammerList = new ReloadHashSet<>(),
			sWireCutterList = new ReloadHashSet<>(),
			sSolderingToolList = new ReloadHashSet<>(),
			sSolderingMetalList = new ReloadHashSet<>();
	/**
	 * The List of Hazmat Armors
	 */
	public static final ReloadHashSet<ItemStackData>
			sGasHazmatList = new ReloadHashSet<>(),
			sBioHazmatList = new ReloadHashSet<>(),
			sFrostHazmatList = new ReloadHashSet<>(),
			sHeatHazmatList = new ReloadHashSet<>(),
			sRadioHazmatList = new ReloadHashSet<>(),
			sElectroHazmatList = new ReloadHashSet<>();
	/**
	 * These Lists are getting executed at their respective timings.
	 * Useful if you have to do things right before/after I do them, without having to control the load order.
	 * Add your "Commands" in the Constructor or in a static Code Block of your Mods Main Class.
	 * These are not Threaded, I just use a native Java Interface for their execution.
	 * Implement just the Method run() and everything should work
	 */
	public static List<Runnable> sBeforeGTPreload = new ArrayList<>(),
			sAfterGTPreload = new ArrayList<>(),
			sBeforeGTLoad = new ArrayList<>(),
			sAfterGTLoad = new ArrayList<>(),
			sBeforeGTPostload = new ArrayList<>(),
			sAfterGTPostload = new ArrayList<>(),
			sFirstWorldTick = new ArrayList<>(),
			sBeforeGTServerstart = new ArrayList<>(),
			sAfterGTServerstart = new ArrayList<>(),
			sBeforeGTServerstop = new ArrayList<>(),
			sAfterGTServerstop = new ArrayList<>(),
			sGTBlockIconload = new ArrayList<>(),
			sGTItemIconload = new ArrayList<>();
	/**
	 * Getting assigned by the Mod loading
	 */
	public static boolean
			sUnificationEntriesRegistered = false,
			sPreloadStarted = false,
			sPreloadFinished = false,
			sLoadStarted = false,
			sLoadFinished = false,
			sPostloadStarted = false,
			sPostloadFinished = false;
	
	public static final int MAX_MATERIALS = 2000;
	public static final Materials[] sGeneratedMaterials = new Materials[MAX_MATERIALS];
	
	@SideOnly(Side.CLIENT)
	public static IIconRegister sBlockIcons, sItemIcons;
	
	/**
	 * Initialized by the Block creation.
	 */
	public static Block sBlockMachines;
	
	
	//TODO TRANSFER TO CONFIG
	/**
	 * Getting assigned by the Config
	 */
	public static boolean
			sTimber = true,
			sDrinksAlwaysDrinkable = false,
			sMultiThreadedSounds = false,
			sDoShowAllItemsInCreative = false,
			sColoredGUI = true,
			sMachineMetalGUI = false,
			sConstantEnergy = true,
			sMachineExplosions = true,
			sMachineFlammable = true,
			sMachineNonWrenchExplosions = true,
			sMachineRainExplosions = true,
			sMachineThunderExplosions = true,
			sMachineFireExplosions = true,
			sMachineWireFire = true,
			meIOLoaded = false,
			mRFExplosions = false,
			mServerStarted = false,
			mIC2Classic = false,
			mMagneticraft = false,
			mImmersiveEngineering = false,
			mGTPlusPlus = false,
			mTranslocator = false,
			mTConstruct = false,
			mGalacticraft = false,
			mForceFreeFace = true,
			mExplosionItemDrop = false;
	
	public static boolean gt6Pipe = true;
	public static boolean gt6Cable = true;
	public static boolean ic2EnergySourceCompat = true;
	public static boolean costlyCableConnection = false;
	
	public static boolean mAE2Integration = true;
	
	/**
	 * This enables ambient-occlusion smooth lighting on tiles
	 */
	public static boolean mRenderTileAmbientOcclusion = true;
	
	/**
	 * This enables rendering of glowing textures
	 */
	public static boolean mRenderGlowTextures = true;
	
	/**
	 * Render flipped textures
	 */
	public static boolean mRenderFlippedMachinesFlipped = false;
	
	/**
	 * This enables indicators on input/output hatches
	 */
	public static boolean mRenderIndicatorsOnHatch = true;
	
	/**
	 * This enables the rendering of dirt particles if pollution is enabled too
	 */
	public static boolean mRenderDirtParticles = true;
	
	/**
	 * This enables the rendering of the pollution fog if pollution is enabled too
	 */
	public static boolean mRenderPollutionFog = true;
	public static int
			mEUtoRF = 360,
			mRFtoEU = 20,
			mWireHeatingTicks = 4;
	
	public static int
			TICKS_FOR_LAG_AVERAGING = 25,
			MILLISECOND_THRESHOLD_UNTIL_LAG_WARNING = 100;
	/**
	 * This gives you a new BaseMetaTileEntity. As some Interfaces are not always loaded (Buildcraft, Univeral Electricity) I have to use Invocation at the Constructor of the BaseMetaTileEntity
	 */
	private static Class sBaseMetaTileEntityClass = null;
	
	public static void registerCover(ItemStack stack, ITexture aCover, SA_CoverBehavior aBehavior) {
		registerCover(stack, aCover, (SA_CoverBehaviorBase<?>) aBehavior);
	}
	
	public static void registerCover(ItemStack stack, ITexture aCover, SA_CoverBehaviorBase<?> aBehavior) {
		if (!sCovers.containsKey(new ItemStackData(stack))) sCovers.put(new ItemStackData(stack), aCover == null || !aCover.isValidTexture() ? Textures.BlockIcons.ERROR_RENDERING[0] : aCover);
		if (aBehavior != null) sCoverBehaviors.put(new ItemStackData(stack), aBehavior);
	}
	
	public static void registerCoverBehavior(ItemStack stack, SA_CoverBehavior aBehavior) {
		registerCoverBehavior(stack, (SA_CoverBehaviorBase<?>) aBehavior);
	}
	
	public static void registerCoverBehavior(ItemStack stack, SA_CoverBehaviorBase<?> aBehavior) {
		sCoverBehaviors.put(new ItemStackData(stack), aBehavior == null ? sDefaultBehavior : aBehavior);
	}
	
	/**
	 * Registers multiple Cover Items. I use that for the OreDict Functionality.
	 *
	 * @param aBehavior can be null
	 */
	public static void registerCover(Collection<ItemStack> aStackList, ITexture aCover, SA_CoverBehavior aBehavior) {
		registerCover(aStackList, aCover, aBehavior);
	}
	
	/**
	 * Registers multiple Cover Items. I use that for the OreDict Functionality.
	 *
	 * @param aBehavior can be null
	 */
	public static void registerCover(Collection<ItemStack> aStackList, ITexture aCover, SA_CoverBehaviorBase<?> aBehavior) {
		if (aCover.isValidTexture()) aStackList.forEach(tStack -> registerCover(tStack, aCover, aBehavior));
	}
	
	/**
	 * returns a Cover behavior, guaranteed to not return null after preload
	 */
	@Deprecated
	public static SA_CoverBehavior getCoverBehavior(ItemStack stack) {
		if (stack == null || stack.getItem() == null) return sNoBehavior;
		SA_CoverBehaviorBase<?> rCover = sCoverBehaviors.get(new ItemStackData(stack));
		if (!(rCover instanceof SA_CoverBehavior) || rCover == null) return sDefaultBehavior;
		return (SA_CoverBehavior) rCover;
	}
	
	/**
	 * returns a Cover behavior, guaranteed to not return null after preload
	 *
	 * @return
	 */
	public static SA_CoverBehaviorBase<?> getCoverBehaviorNew(ItemStack stack) {
		if (stack == null || stack.getItem() == null) return sNoBehavior;
		SA_CoverBehaviorBase<?> rCover = sCoverBehaviors.get(new ItemStackData(stack));
		if (rCover != null) return rCover;
		rCover = sCoverBehaviors.get(new ItemStackData(stack, true));
		if (rCover != null) return rCover;
		return sDefaultBehavior;
	}
	
	/**
	 * returns a Cover behavior, guaranteed to not return null
	 */
	@Deprecated
	public static SA_CoverBehavior getCoverBehavior(int stack) {
		if (stack == 0) return sNoBehavior;
		return getCoverBehavior(Utility.intToStack(stack));
	}
	
	/**
	 * returns a Cover behavior, guaranteed to not return null
	 */
	public static SA_CoverBehaviorBase<?> getCoverBehaviorNew(int stack) {
		if (stack == 0) return sNoBehavior;
		return getCoverBehaviorNew(Utility.intToStack(stack));
	}
	
	/**
	 * Causes a Machineblock Update
	 * This update will cause surrounding MultiBlock Machines to update their Configuration.
	 * You should call this Function in @Block.breakBlock and in @Block.onBlockAdded of your Machine.
	 *
	 * @param world is being the World
	 * @param x     is the X-Coord of the update causing Block
	 * @param y     is the Y-Coord of the update causing Block
	 * @param z     is the Z-Coord of the update causing Block
	 */
	public static boolean causeMachineUpdate(World world, int x, int y, int z) {
		if (world != null && !world.isRemote) { // World might be null during Worldgen
			TileEntityUpdateThread.setMachineUpdateValues(world, new ChunkCoordinates(x, y, z));
			return true;
		}
		return false;
	}
	
	public static boolean causeCableUpdate(World world, int x, int y, int z) {
		if (world != null && !world.isRemote) { // World might be null during Worldgen
			CableUpdateThreadThread.setCableUpdateValues(world, new ChunkCoordinates(x, y, z));
			return true;
		}
		return false;
	}
	
	/**
	 * Adds a Multi-Machine Block, like my Machine Casings for example.
	 * You should call @causeMachineUpdate in @Block.breakBlock and in @Block.onBlockAdded of your registered Block.
	 * You don't need to register TileEntities which implement @IMachineBlockUpdate
	 *
	 * @param block the Block
	 * @param aMeta  the Metadata of the Blocks as Bitmask! -1 or ~0 for all Metavalues
	 */
	public static boolean registerMachineBlock(Block block, int aMeta) {
		if (block == null)
			return false;
		sMachineIDs.put(block, aMeta);
		return true;
	}
	
	/**
	 * if this Block is a Machine Update Conducting Block
	 */
	public static boolean isMachineBlock(Block block, int aMeta) {
		if (block != null) {
			Integer id = sMachineIDs.get(block);
			return id != null;
		}
		return false;
	}
	
	;
	
	/**
	 * Sets the {@link IIconRegister} for Block Icons
	 *
	 * @param aIconRegister The {@link IIconRegister} Icon Register
	 */
	@SideOnly(Side.CLIENT)
	public static void setBlockIconRegister(IIconRegister aIconRegister) {
		sBlockIcons = aIconRegister;
	}
	
	/**
	 * Sets the {@link IIconRegister} for Items Icons
	 *
	 * @param aIconRegister The {@link IIconRegister} Icon Register
	 */
	@SideOnly(Side.CLIENT)
	public static void setItemIconRegister(IIconRegister aIconRegister) {
		sItemIcons = aIconRegister;
	}
	
	public static BaseMetaTileEntity constructBaseMetaTileEntity() {
		if (sBaseMetaTileEntityClass == null) {
			try {
				return (BaseMetaTileEntity) (sBaseMetaTileEntityClass = BaseMetaTileEntity.class).newInstance();
			} catch (Throwable e) {/*Do nothing*/}
		}
		
		try {
			return (BaseMetaTileEntity) (sBaseMetaTileEntityClass.newInstance());
		} catch (Throwable e) {
			SpaceLog.err.println("GT_Mod: Fatal Error ocurred while initializing TileEntities, crashing Minecraft.");
			e.printStackTrace(SpaceLog.err);
			throw new RuntimeException(e);
		}
	}
	
	public static void registerCable(Materials mat, int id, long lossIfInsulate, long loss, long amp, long vol, boolean isInsulate, boolean isAutoInsulate) {
		String name = "%material";
		
		String aTextWire1 = "wire.";
		String aTextWire2 = " Wire";
		String aTextCable1 = "cable.";
		String aTextCable2 = " Cable";
		
		String enmWire = "wireGt";
		String enmCable = "cableGt";
		
		int[] cables = {1, 2, 3, 4, 6, 8, 9, 12, 16};
		float[] aThickNess = {0.128F, 0.186F, 0.248F, 0.310F, 0.434F, 0.558F, 0.620F, 0.806F, 0.992F};
		
		for (int i = 0; i < cables.length; i++) {
			
			OrePrefixes currentWire = OrePrefixes.valueOf(enmWire + cables[i]);
			
			if (!mat.isGeneratedType(currentWire)) continue;
			
			registerOre(currentWire, mat, new Cable_Electricity(id + i, aTextWire1 + mat.name.toLowerCase() + "." + cables[i],
							cables[i] + "x " + name + aTextWire2, aThickNess[i], mat, loss, cables[i] * amp, vol, false, !isAutoInsulate
					).get(1L)
			);
			
			if (isInsulate) {
				int start = id + cables.length;
				OrePrefixes currentCable = OrePrefixes.valueOf(enmCable + cables[i]);
				registerOre(currentCable, mat, new Cable_Electricity(start + i, aTextCable1 + mat.name.toLowerCase() + "." + cables[i],
						cables[i] + "x " + name + aTextCable2, aThickNess[i], mat, lossIfInsulate, cables[i] * amp, vol, true, false)
						.get(1L)
				);
			}
		}
	}
	
	public static void generateItemPipes(Materials aMaterial, String name, int startID, int baseInvSlots){
		generateItemPipes(aMaterial, name, "%material", startID, baseInvSlots);
	}
	
	public static void generateItemPipes(Materials aMaterial, String name, String displayName, int startID, int baseInvSlots) {
		OrePrefixes[] pipesOre = {OrePrefixes.pipeTiny, OrePrefixes.pipeSmall, OrePrefixes.pipeMedium, OrePrefixes.pipeLarge, OrePrefixes.pipeHuge};
		float[] thickness = { 0.25F, 0.375F, 0.5F, 0.75F, 0.875F };
		int[] step = { 131072, 65536, 32768, 16384, 8192 };
		
		for (int i = 0; i < pipesOre.length; i++) {
			OreDictUnifier.registerOre(pipesOre[i].get(aMaterial), new Pipe_Item(startID + i, "GT_Pipe_" + name + "_" + pipesOre[i].prefix.trim(),
					pipesOre[i].prefix + displayName + " Item Pipe", thickness[i], aMaterial, baseInvSlots, step[i] / baseInvSlots, false).get(1L)
			);
		}
	}
	
	public static void generateFluidPipes(Materials aMaterial, String name, int startID, int baseCapacity, int heatCapacity){
		generateFluidPipes(aMaterial, name, "%material", startID, baseCapacity, heatCapacity);
	}
	
	public static void generateFluidPipes(Materials aMaterial, String name, String displayName, int startID, int baseCapacity, int heatCapacity){
		OrePrefixes[] pipesOre = {OrePrefixes.pipeTiny, OrePrefixes.pipeSmall, OrePrefixes.pipeMedium, OrePrefixes.pipeLarge, OrePrefixes.pipeHuge};
		float[] thickness = {0.25F, 0.375F, 0.5F, 0.75F, 0.875F};
		int[] capacity = { baseCapacity / 6, baseCapacity / 3, baseCapacity, baseCapacity * 2, baseCapacity * 4};
		
		for (int i = 0; i < pipesOre.length; i++) {
			OreDictUnifier.registerOre(pipesOre[i].get(aMaterial), new Pipe_Fluid(startID + i, "GT_Pipe_" + name + "_" + pipesOre[i].prefix.trim(),
					pipesOre[i].prefix + displayName + " Fluid Pipe", thickness[i], aMaterial, capacity[i], heatCapacity, true).get(1L)
			);
		}
	}
	
	public static void generateFluidMultiPipes(Materials aMaterial, String name, int startID, int baseCapacity, int heatCapacity, boolean gasProof){
		generateFluidMultiPipes(aMaterial, name, "%material", startID, baseCapacity, heatCapacity, gasProof);
	}
	
	public static void generateFluidMultiPipes(Materials aMaterial, String name, String displayName, int startID, int baseCapacity, int heatCapacity, boolean gasProof){
		OreDictUnifier.registerOre(OrePrefixes.pipeQuadruple.get(aMaterial), new Pipe_Fluid(startID, "GT_Pipe_" + name + "_Quadruple",
				"Quadruple " + displayName + " Fluid Pipe", 1.0F, aMaterial, baseCapacity, heatCapacity, gasProof, 4).get(1L));
		OreDictUnifier.registerOre(OrePrefixes.pipeNonuple.get(aMaterial), new Pipe_Fluid(startID + 1, "GT_Pipe_" + name + "_Nonuple",
				"Nonuple " + displayName + " Fluid Pipe", 1.0F, aMaterial, baseCapacity / 3, heatCapacity, gasProof, 9).get(1L));
	}
	
	
	/**
	 * Generic Function to add Tools to the Lists.
	 * Contains all sanity Checks for Tools, like preventing one Tool from being registered for multiple purposes as controls would override each other.
	 */
	public static boolean registerTool(ItemStack aTool, Collection<ItemStackData> aToolList) {
		if (aTool == null || isStackInList(aTool, sToolList) || (!aTool.getItem().isDamageable() && !isElectricItem(aTool) && !(aTool.getItem() instanceof IDamagableItem)))
			return false;
		aToolList.add(new ItemStackData(copyAmount(1, aTool)));
		sToolList.add(new ItemStackData(copyAmount(1, aTool)));
		return true;
	}
}
